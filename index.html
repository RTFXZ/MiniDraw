<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MiniDraw - by RTFXZ</title>
  <meta name="description" content="MiniDraw — lightweight drawing app. Try it online or download for offline use." />
  
  <!-- Favicon line goes here -->
  <link rel="icon" type="image/png" href="/logo21.png">
  
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,monospace;background:linear-gradient(180deg,#030712 0%, #071428 100%);color:#e6eef6}
    .app{display:grid;grid-template-columns:320px 1fr;height:100vh;gap:18px;padding:18px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .toolbar{display:flex;flex-direction:column;gap:12px}
    .row{display:flex;gap:8px;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type=range]{width:100%}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.primary{background:var(--accent);color:#001; border:none}
    canvas{display:block;width:100%;height:100%;border-radius:12px;background:linear-gradient(180deg,#ffffff 0%,#f8fafc 100%);box-shadow:inset 0 1px 0 rgba(255,255,255,0.6)}
    .meta{font-size:12px;color:var(--muted)}
    .flex{display:flex;gap:8px}
    .spacer{flex:1}
    footer{font-size:12px;color:var(--muted);margin-top:8px;text-align:center}
    @media (max-width:900px){.app{grid-template-columns:1fr;grid-template-rows:auto 1fr;padding:10px}.panel{order:2}}
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel toolbar" aria-label="tools">
      <div>
        <h3 style="margin:0 0 8px 0">MiniDraw</h3>
        <div class="meta">Single-file, offline, touch & mouse support</div>
      </div>

      <div class="row">
        <label for="color">Color</label>
        <input id="color" type="color" value="#0b3cff" style="margin-left:8px" />
      </div>

      <div class="row">
        <label for="size">Brush</label>
        <input id="size" type="range" min="1" max="80" value="6" />
        <div id="sizeVal" style="width:36px;text-align:right">6</div>
      </div>

      <div class="row">
        <label for="opacity">Opacity</label>
        <input id="opacity" type="range" min="0.05" max="1" step="0.05" value="1" />
        <div id="opVal" style="width:36px;text-align:right">1.00</div>
      </div>

      <div class="row">
        <button id="penBtn" class="primary">Pen</button>
        <button id="eraserBtn">Eraser</button>
      </div>

      <div class="row">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
        <button id="clearBtn">Clear</button>
      </div>

      <div class="row">
        <button id="saveBtn">Save PNG</button>
        <button id="downloadBtn">Download HTML</button>
      </div>

      <div class="row">
        <div class="meta">Tips: pinch-zoom on mobile, Ctrl+Z to undo, right-click to toggle eraser.</div>
      </div>

      <footer>Made with Canvas • Works offline</footer>
    </aside>

    <main class="panel" style="padding:12px;display:flex;flex-direction:column;gap:12px">
      <div style="flex:1;position:relative;min-height:280px">
        <canvas id="draw"></canvas>
      </div>
      <div class="meta">Canvas auto-resizes to fit (preserves drawing). Undo stack limited to 25 states.</div>
    </main>
  </div>

<script>
(() => {
  const canvas = document.getElementById('draw');
  const ctx = canvas.getContext('2d', { alpha: false });
  let drawing = false;
  let erasing = false;
  let last = { x: 0, y: 0 };

  // UI
  const colorEl = document.getElementById('color');
  const sizeEl = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const opacityEl = document.getElementById('opacity');
  const opVal = document.getElementById('opVal');
  const penBtn = document.getElementById('penBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  // Undo/Redo stack — store dataURLs (lightweight) — keep limited
  const undoStack = [];
  const redoStack = [];
  const MAX_STACK = 25;

  function pushState() {
    try {
      if (undoStack.length >= MAX_STACK) undoStack.shift();
      undoStack.push(canvas.toDataURL());
      // once new state created, clear redo
      redoStack.length = 0;
      updateButtons();
    } catch (e) { console.warn('pushState failed', e); }
  }

  function restoreFromDataURL(dataURL) {
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      updateButtons();
    };
    img.src = dataURL;
  }

  function undo() {
    if (!undoStack.length) return;
    const lastState = undoStack.pop();
    redoStack.push(canvas.toDataURL());
    if (undoStack.length) restoreFromDataURL(undoStack[undoStack.length - 1]);
    else { // blank
      ctx.clearRect(0,0,canvas.width,canvas.height);
      updateButtons();
    }
  }

  function redo() {
    if (!redoStack.length) return;
    const state = redoStack.pop();
    undoStack.push(state);
    restoreFromDataURL(state);
  }

  function updateButtons(){
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // resize handling — keep content by using temp canvas
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    // capture existing
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width || rect.width;
    tmp.height = canvas.height || rect.height;
    tmp.getContext('2d').drawImage(canvas, 0, 0);

    canvas.width = Math.floor(rect.width);
    canvas.height = Math.floor(rect.height);

    // restore
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(tmp, 0, 0, tmp.width, tmp.height, 0, 0, canvas.width, canvas.height);
  }

  // initialize size to fill main area
  function fitCanvasToContainer() {
    const main = canvas.parentElement;
    const rect = main.getBoundingClientRect();
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    resizeCanvas();
  }

  // pointer handling (works for mouse & touch)
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    drawing = true;
    last = { x: e.offsetX, y: e.offsetY };
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    pushState();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!drawing) return;
    const x = e.offsetX, y = e.offsetY;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = parseFloat(sizeEl.value) * (erasing ? 2 : 1);
    ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
    ctx.globalAlpha = parseFloat(opacityEl.value);
    if (!erasing) ctx.strokeStyle = colorEl.value;
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ctx.lineTo(x, y);
    ctx.stroke();
    last = { x, y };
  });

  canvas.addEventListener('pointerup', (e) => {
    canvas.releasePointerCapture(e.pointerId);
    drawing = false;
  });

  canvas.addEventListener('pointercancel', () => { drawing = false; });

  // UI interactions
  sizeEl.addEventListener('input', () => { sizeVal.textContent = sizeEl.value; });
  opacityEl.addEventListener('input', () => { opVal.textContent = parseFloat(opacityEl.value).toFixed(2); });

  penBtn.addEventListener('click', () => { erasing = false; penBtn.classList.add('primary'); eraserBtn.classList.remove('primary'); });
  eraserBtn.addEventListener('click', () => { erasing = true; eraserBtn.classList.add('primary'); penBtn.classList.remove('primary'); });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  clearBtn.addEventListener('click', () => { pushState(); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); });

  saveBtn.addEventListener('click', () => {
    const dataURL = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = `minidraw-${Date.now()}.png`;
    a.click();
  });

  // download current HTML (self-contained)
  downloadBtn.addEventListener('click', () => {
    const html = `<!doctype html>\n${document.documentElement.outerHTML}`;
    const blob = new Blob([html], { type: 'text/html' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `minidraw-${Date.now()}.html`;
    a.click();
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
    if (e.key === 'e') { erasing = !erasing; eraserBtn.classList.toggle('primary'); penBtn.classList.toggle('primary'); }
  });

  // right click toggles eraser
  canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); erasing = !erasing; eraserBtn.classList.toggle('primary'); penBtn.classList.toggle('primary'); });

  // init
  function init(){
    fitCanvasToContainer();
    // fill white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // initial state
    pushState();
    penBtn.classList.add('primary');
    updateButtons();
  }

  // resize observer for responsive canvas
  const ro = new ResizeObserver(() => {
    // preserve drawing — make sure to push state before resize to allow undo
    const before = canvas.toDataURL();
    fitCanvasToContainer();
    // restore previous pixels into resized canvas
    restoreFromDataURL(before);
  });
  ro.observe(canvas.parentElement);

  // start
  init();
})();
</script>
</body>
</html>
